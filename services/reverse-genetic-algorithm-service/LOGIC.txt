ЛОГИКА РАБОТЫ СЕРВИСА ОБРАТНОГО ГЕНЕТИЧЕСКОГО АЛГОРИТМА
================================================================

ТЕОРИЯ
------

Генетический алгоритм - это эвристический метод оптимизации, основанный на принципах естественного отбора и генетики.
Алгоритм работает с популяцией решений, применяя операции скрещивания (crossover), мутации (mutation) и селекции (selection)
для поиска оптимального решения.

В данном сервисе реализован настоящий генетический алгоритм, где:
- Хромосома = вектор из 6 весов для метрик (avg_price, success_rate, avg_delivery_time, denial_rate, orders_count, total_revenue)
- Скрещивание = комбинирование весов двух родителей (cxBlend - смешивание весов)
- Мутация = случайное изменение весов в хромосоме (гауссова мутация)
- Fitness функция = поиск оптимальных весов, которые максимизируют лучший fitness среди всех элементов

Обратный генетический алгоритм в данном проекте работает наоборот по сравнению с обычным:
- Обычный алгоритм: сначала ранжирует поставщиков, затем для каждого поставщика ранжирует его автозапчасти
- Обратный алгоритм: сначала ранжирует все автозапчасти (артикул+бренд), затем для каждой автозапчасти ранжирует поставщиков

Этап 1: Рейтинг всех автозапчастей
- Получает все уникальные комбинации артикул+бренд из базы данных
- Агрегирует метрики по всем поставщикам для каждой комбинации
- Нормализует метрики и запускает генетический алгоритм
- Ранжирует все комбинации по fitness_score

Этап 2: Рейтинг поставщиков по каждой автозапчасти
- Для каждой комбинации артикул+бренд получает метрики у каждого поставщика
- Нормализует метрики поставщиков для этой конкретной комбинации
- Запускает генетический алгоритм для ранжирования поставщиков
- Возвращает отсортированный список поставщиков

ОПИСАНИЕ РАБОТЫ
---------------

Сервис состоит из двух основных компонентов:
1. FastAPI приложение (main.py) - предоставляет HTTP endpoints
2. Логика генетического алгоритма (reverse_genetic_algorithm_logic.py) - содержит всю бизнес-логику

ПЕРЕМЕННЫЕ И ФУНКЦИИ
--------------------

КЛАСС: ReverseGeneticAlgorithmService

ПЕРЕМЕННЫЕ ЭКЗЕМПЛЯРА:
- redis_client: объект подключения к Redis для кеширования
- db_connection: объект подключения к PostgreSQL для работы с базой данных

МЕТОДЫ:

1. _get_all_article_brand_combinations()
   Назначение: Получает все уникальные комбинации артикул+бренд с агрегированными метриками
   
   SQL запрос:
   - Группирует order_product по article и brand
   - Агрегирует метрики: orders_count, total_revenue, avg_price, success_rate, avg_delivery_time, denial_rate
   - Фильтрует только комбинации с orders_count > 0
   
   Возвращает: список словарей, каждый содержит:
   - article: артикул
   - brand: бренд
   - orders_count: количество заказов
   - total_revenue: общая выручка
   - avg_price: средняя цена
   - success_rate: процент успешных заказов
   - avg_delivery_time: среднее время доставки
   - denial_rate: процент отказов

2. _normalize_features(items)
   Назначение: Нормализует метрики для корректного сравнения
   
   Параметры:
   - items: список элементов с метриками
   
   Процесс:
   - Извлекает 6 метрик: avg_price, success_rate, avg_delivery_time, denial_rate, orders_count, total_revenue
   - Создает матрицу признаков
   - Вычисляет min и max значения для каждой метрики
   - Нормализует значения в диапазон [0, 1] по формуле: (value - min) / (max - min)
   - Добавляет normalized_features к каждому элементу
   
   Возвращает: список элементов с добавленным полем normalized_features

3. _fitness_function(individual, items)
   Назначение: Вычисляет fitness score для хромосомы (весов)
   
   Параметры:
   - individual: хромосома - вектор из 6 весов [w1, w2, w3, w4, w5, w6]
   - items: список элементов с нормализованными признаками
   
   Процесс:
   - Нормализует веса (сумма = 1.0)
   - Для каждого элемента вычисляет fitness с использованием весов из хромосомы:
     * price_score = 1.0 - features[0] (меньше цена - лучше)
     * success_score = features[1] (больше успешность - лучше)
     * delivery_score = 1.0 - features[2] (меньше время доставки - лучше)
     * denial_score = 1.0 - features[3] (меньше отказов - лучше)
     * orders_score = features[4] (больше заказов - лучше)
     * revenue_score = features[5] (больше выручка - лучше)
   - Находит максимальный fitness среди всех элементов
   
   Возвращает: кортеж (best_fitness,) - лучший fitness, достижимый с данными весами

4. _create_individual(items)
   Назначение: Создает случайную хромосому (вектор весов) для популяции
   
   Параметры:
   - items: список элементов (не используется, но нужен для совместимости)
   
   Процесс:
   - Генерирует 6 случайных весов в диапазоне [0.0, 1.0]
   - Нормализует веса так, чтобы их сумма равнялась 1.0
   
   Возвращает: список [w1, w2, w3, w4, w5, w6] - нормализованные веса

5. _mutate_individual(individual, items)
   Назначение: Мутирует хромосому (изменяет веса)
   
   Параметры:
   - individual: хромосома - вектор весов
   - items: список элементов (не используется, но нужен для совместимости)
   
   Процесс:
   - Для каждого веса с вероятностью 30% применяет гауссову мутацию
   - Мутация: weight = weight + random.gauss(0, 0.1)
   - Ограничивает веса в диапазоне [0.0, 1.0]
   - Нормализует веса так, чтобы их сумма равнялась 1.0
   
   Возвращает: кортеж (mutated_individual,)

6. _run_genetic_algorithm(items)
   Назначение: Запускает генетический алгоритм для поиска лучшего элемента
   
   Параметры:
   - items: список элементов с метриками
   
   Процесс:
   - Проверяет граничные случаи (0 или 1 элемент)
   - Создает типы FitnessMax и Individual через DEAP creator
   - Регистрирует операции в toolbox:
     * individual: создание хромосомы (вектор весов)
     * population: создание популяции хромосом
     * evaluate: вычисление fitness (поиск лучшего элемента с данными весами)
     * mate: скрещивание (cxBlend - смешивание весов двух родителей)
     * mutate: мутация (гауссова мутация весов)
     * select: селекция (selTournament)
   - Вычисляет tournsize = min(3, len(items))
   - Вычисляет population_size = min(50, max(2, len(items) * 2))
   - Создает начальную популяцию
   - Запускает эволюцию на 30 поколений:
     * varAnd: применяет скрещивание и мутацию
     * evaluate: вычисляет fitness для потомков
     * select: выбирает лучших для следующего поколения
   - Обрабатывает особые случаи:
     * Если len(offspring) == 0: прерывает цикл
     * Если len(offspring) == 1: использует этот элемент
     * Если len(offspring) == 2: использует оба элемента
     * Корректирует tournsize для избежания ошибок
   - Выбирает лучшую хромосому (веса) из финальной популяции
   - Использует найденные оптимальные веса для вычисления fitness всех элементов
   - Выбирает элемент с максимальным fitness
   
   Возвращает: кортеж (best_item, optimal_weights) - лучший элемент и оптимальные веса

7. _get_suppliers_for_article_brand(article, brand)
   Назначение: Получает всех поставщиков для конкретной комбинации артикул+бренд
   
   Параметры:
   - article: артикул
   - brand: бренд
   
   SQL запрос:
   - Фильтрует order_product по article и brand
   - Группирует по поставщикам (service_name)
   - Агрегирует метрики для каждого поставщика
   
   Возвращает: список словарей поставщиков с метриками

8. _analyze_suppliers_for_article_brand(article, brand)
   Назначение: Анализирует и ранжирует поставщиков для конкретной автозапчасти
   
   Параметры:
   - article: артикул
   - brand: бренд
   
   Процесс:
   - Получает поставщиков через _get_suppliers_for_article_brand
   - Обрабатывает граничные случаи (0, 1 или 2 поставщика)
   - Нормализует метрики поставщиков
   - Запускает генетический алгоритм для поиска оптимальных весов
   - Получает оптимальные веса из генетического алгоритма
   - Вычисляет fitness для всех поставщиков с использованием оптимальных весов
   - Сортирует по fitness_score
   
   Возвращает: отсортированный список поставщиков с fitness_score и метриками

9. find_best_article_brands()
   Назначение: Главная функция - находит лучшие автозапчасти и ранжирует поставщиков
   
   Процесс:
   - Получает все комбинации артикул+бренд
   - Обрабатывает граничные случаи (0 или 1 комбинация)
   - Нормализует метрики комбинаций
   - Запускает генетический алгоритм для поиска оптимальных весов
   - Получает оптимальные веса из генетического алгоритма
   - Вычисляет fitness для всех комбинаций с использованием оптимальных весов
   - Сортирует комбинации по fitness_score
   - Для каждой комбинации анализирует поставщиков через _analyze_suppliers_for_article_brand
   - Формирует результат:
     * best_article_brand: лучшая комбинация с рейтингом поставщиков
     * all_article_brands_ranking: все комбинации отсортированные
     * article_brands_with_suppliers: комбинации с рейтингами поставщиков
   
   Возвращает: словарь с результатами анализа

ПОТОК ДАННЫХ
------------

1. HTTP запрос -> FastAPI endpoint /find-best-article-brands
2. Вызов find_best_article_brands()
3. Получение всех комбинаций артикул+бренд из БД
4. Нормализация метрик комбинаций
5. Запуск генетического алгоритма для ранжирования комбинаций
6. Для каждой комбинации:
   a. Получение поставщиков из БД
   b. Нормализация метрик поставщиков
   c. Запуск генетического алгоритма для ранжирования поставщиков
7. Формирование результата
8. Возврат JSON ответа

ОСОБЕННОСТИ РЕАЛИЗАЦИИ
----------------------

1. Обработка граничных случаев:
   - 0 элементов: возврат пустого результата
   - 1 элемент: возврат этого элемента с fitness = 1.0
   - 2 элемента: простая сортировка без генетического алгоритма

2. Нормализация метрик:
   - Используется min-max нормализация
   - Защита от деления на ноль (ranges == 0 заменяется на 1)

3. Генетический алгоритм:
   - Хромосома: вектор из 6 весов (нормализованных, сумма = 1.0)
   - Размер популяции: min(50, max(2, len(items) * 2))
   - Размер турнира: min(3, len(items))
   - Количество поколений: 30
   - Вероятность скрещивания: 0.5
   - Вероятность мутации: 0.2
   - Тип скрещивания: cxBlend (смешивание весов с alpha=0.5)
   - Тип мутации: гауссова мутация (сила = 0.1, вероятность = 30% на ген)

4. Обработка ошибок:
   - Проверка размера offspring перед селекцией
   - Корректировка tournsize для избежания ошибок randrange
   - Логирование ошибок с контекстом

МЕТРИКИ ДЛЯ ОЦЕНКИ
------------------

1. avg_price - средняя цена (меньше лучше)
2. success_rate - процент успешных заказов (больше лучше)
3. avg_delivery_time - среднее время доставки (меньше лучше)
4. denial_rate - процент отказов (меньше лучше)
5. orders_count - количество заказов (больше лучше)
6. total_revenue - общая выручка (больше лучше)

ВЕСА МЕТРИК
-----------

- avg_price: 0.2 (20%)
- success_rate: 0.25 (25%)
- avg_delivery_time: 0.15 (15%)
- denial_rate: 0.15 (15%)
- orders_count: 0.1 (10%)
- total_revenue: 0.15 (15%)

СУММА ВЕСОВ: 1.0 (100%)

